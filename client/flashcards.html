<script>
  /**
   * Load a specific deck
   * 
   * @param {string} deckName - Name of the deck to load
   */
  function loadDeck(deckName) {
    showLoadingIndicator();
    
    google.script.run
      .withSuccessHandler(function(result) {
        hideLoadingIndicator(); // Hide indicator once response is received

        if (result && result.success) { // Check if result is truthy AND has success property
          console.log('[loadDeck] Success. Server result:', result);
          if (result.cards && result.cards.length > 0) {
            // Normalize card properties for client-side logging and consistency
            const normalizedCard = {
              id: result.cards[0].id || result.cards[0].FlashcardID,
              sideA: result.cards[0].sideA || result.cards[0].FlashcardSideA,
              sideB: result.cards[0].sideB || result.cards[0].FlashcardSideB,
              sideC: result.cards[0].sideC || result.cards[0].FlashcardSideC,
              tags: result.cards[0].tags || result.cards[0].Tags,
              StudyConfig: result.cards[0].StudyConfig // Keep original StudyConfig
            };
            console.log('[loadDeck] First card (normalized for logging):', JSON.parse(JSON.stringify(normalizedCard)));
          } else {
            console.log('[loadDeck] No cards received or cards array is empty.');
          }
          
          // Store deck data
          window.app.currentDeck = deckName;
          
          // Show the flashcard view
          displayFlashcardView(result);
        } else {
          // Handle error or unexpected result
          const errorMsg = result ? result.message : `Failed to load deck "${escapeHtml(deckName)}". Received an unexpected or null response from the server.`;
          console.error('[loadDeck] Error or unexpected result:', result);
          handleError(errorMsg);
        }
      })
      .withFailureHandler(function(err) {
        // handleError in main.html already calls hideLoadingIndicator()
        const errorDetail = err && err.message ? err.message : 'Unknown error';
        console.error('[loadDeck] Failure handler triggered:', err);
        handleError(`An error occurred while loading deck "${escapeHtml(deckName)}": ${errorDetail}`);
      })
      .getFlashcardsForDeck(deckName);
  }

  /**
   * Display the flashcard study view
   * 
   * @param {Object} deckData - The deck data with cards
   */
  function displayFlashcardView(deckData) {
    console.log('[displayFlashcardView] Called with deck data:', deckData);
    
    if (!deckData || !deckData.cards || deckData.cards.length === 0) {
      const contentArea = document.getElementById('appContent');
      contentArea.innerHTML = `
        <div class="card">
          <div class="card-title">No Cards Available</div>
          <p>This deck doesn't have any cards yet. Please contact an administrator to add cards to this deck.</p>
          <div class="form-actions">
            <button id="backToDeckList" class="btn btn-outline">Back to Decks</button>
          </div>
        </div>
      `;
      
      const backButton = document.getElementById('backToDeckList');
      if (backButton) backButton.addEventListener('click', loadDeckList);
      return;
    }
    
    // Store cards in the app state
    window.app.currentCards = deckData.cards;
    window.app.currentCardIndex = 0;
    
    // Display the first card
    displayFlashcard(deckData.cards, 0);
  }

  /**
   * Sets up the custom audio play buttons
   * 
   * @param {Element} container - Container element with audio buttons
   */
  function setupAudioButtons(container) {
    console.log('[setupAudioButtons] Attempting to set up for container:', container);
    if (!container || typeof container.querySelectorAll !== 'function') {
      console.error('[setupAudioButtons] Invalid container provided:', container);
      return;
    }

    const audioButtons = container.querySelectorAll('.audio-play-btn');
    console.log(`[setupAudioButtons] Found ${audioButtons.length} '.audio-play-btn' elements in container:`, container.id || container.className || container.tagName);

    audioButtons.forEach((button, idx) => {
      const originalButtonId = button.id || `button-${idx}`; // For logging
      console.log(`[setupAudioButtons] Processing button #${idx + 1} (ID/Index: ${originalButtonId})`, button);
      
      const audio = button.querySelector('audio');
      
      if (!audio) {
        console.error(`[setupAudioButtons] No <audio> element found as child of button (ID/Index: ${originalButtonId}):`, button);
        return; // Skip this button
      }
      console.log(`[setupAudioButtons] Found <audio> element for button (ID/Index: ${originalButtonId}):`, audio, 'with src:', audio.src);

      // Check if an event listener is already attached (simple check, might not be foolproof)
      if (button.dataset.listenerAttached === 'true') {
        console.warn(`[setupAudioButtons] Listener already attached to button (ID/Index: ${originalButtonId}). Skipping re-attachment.`);
        return;
      }
      button.dataset.listenerAttached = 'true'; // Mark as attached

      button.addEventListener('click', function(e) {
        e.stopPropagation(); // Prevent card from flipping

        console.log(`[AudioButton ${originalButtonId}] Click detected. Audio src:`, audio.src);

        // Stop all other playing audio on the page
        document.querySelectorAll('audio').forEach(otherAudioEl => {
          if (otherAudioEl !== audio && !otherAudioEl.paused) {
            console.log(`[AudioButton ${originalButtonId}] Pausing other audio:`, otherAudioEl.src.slice(0,50));
            otherAudioEl.pause();
            otherAudioEl.currentTime = 0;
            const otherButton = otherAudioEl.closest('.audio-play-btn');
            if (otherButton) {
              otherButton.classList.remove('playing');
              const iconEl = otherButton.querySelector('.material-icons');
              if (iconEl) iconEl.textContent = 'play_arrow';
            }
          }
        });
        
        if (audio.paused) {
          console.log(`[AudioButton ${originalButtonId}] Audio is paused. Attempting to play.`);
          const playPromise = audio.play();
          if (playPromise !== undefined) {
            playPromise.then(_ => {
              console.log(`[AudioButton ${originalButtonId}] Playback started successfully.`);
              button.classList.add('playing');
              const iconEl = button.querySelector('.material-icons');
              if (iconEl) iconEl.textContent = 'pause';
            }).catch(error => {
              console.error(`[AudioButton ${originalButtonId}] Playback failed:`, error);
              button.classList.remove('playing');
              const iconEl = button.querySelector('.material-icons');
              if (iconEl) iconEl.textContent = 'play_arrow';
            });
          } else {
            console.warn(`[AudioButton ${originalButtonId}] audio.play() did not return a promise. Direct state change assumed.`);
          }
        } else {
          console.log(`[AudioButton ${originalButtonId}] Audio is playing. Attempting to pause.`);
          audio.pause();
          audio.currentTime = 0; // Reset to beginning
          button.classList.remove('playing');
          const iconEl = button.querySelector('.material-icons');
          if (iconEl) iconEl.textContent = 'play_arrow';
        }
      });
      
      audio.addEventListener('ended', function() {
        console.log(`[AudioButton ${originalButtonId}] Audio ended.`);
        button.classList.remove('playing');
        const iconEl = button.querySelector('.material-icons');
        if (iconEl) iconEl.textContent = 'play_arrow';
      });

      audio.addEventListener('error', function(e) {
        console.error(`[AudioButton ${originalButtonId}] Error on audio element:`, e);
        button.classList.remove('playing');
        const iconEl = button.querySelector('.material-icons');
        if (iconEl) iconEl.textContent = 'error_outline'; 
      });

      console.log(`[setupAudioButtons] Event listeners attached to button (ID/Index: ${originalButtonId}).`);
    });
  }
  
  function hasValidContent(content) {
    // Basic nullish checks
    if (content === null || content === undefined) return false;
    
    // Type check
    if (typeof content !== 'string') {
      console.log('[hasValidContent] Content is not a string:', typeof content);
      return false;
    }
    
    // Trim the content
    const trimmedContent = content.trim();
    
    // Check for empty content, but allow it if it contains media tags
    if (trimmedContent === '') {
      return content.includes('[IMAGE:') || content.includes('[AUDIO:');
    }
    
    // Non-empty content is always valid
    return true;
  }
  
  /**
   * Display a specific flashcard
   * 
   * @param {Array} cards - Array of cards
   * @param {number} index - Index of the card to display
   */
  function displayFlashcard(cards, index) {
    console.log('[displayFlashcard] Called with index:', index, 'Total cards in current list:', cards ? cards.length : 'N/A');
    
    if (!cards || index >= cards.length) {
      console.log('[displayFlashcard] End of deck reached or invalid card array.');
      showDeckComplete();
      return;
    }
    
    const card = cards[index];
    // Normalize card properties for easier access and logging
    const normalizedCard = {
      id: card.id || card.FlashcardID,
      sideA: card.sideA || card.FlashcardSideA,
      sideB: card.sideB || card.FlashcardSideB,
      sideC: card.sideC || card.FlashcardSideC,
      tags: card.tags || card.Tags,
      StudyConfig: card.StudyConfig // Keep original StudyConfig
    };

    console.log('[displayFlashcard] Current card object (original):', JSON.parse(JSON.stringify(card)));
    console.log('[displayFlashcard] Normalized card properties:', JSON.parse(JSON.stringify(normalizedCard)));

    const contentArea = document.getElementById('appContent');
    
    // Enhanced StudyConfig parsing with better defaults and error handling
    let studyConfig = { showSideB: true, showSideC: true, autoplayAudio: false };

    console.log('[displayFlashcard] Processing StudyConfig for card:', normalizedCard.id || 'unknown');
    console.log('[displayFlashcard] Raw StudyConfig:', normalizedCard.StudyConfig);

    // Ensure string format for parsing
    if (normalizedCard.StudyConfig) {
      if (typeof normalizedCard.StudyConfig === 'object') {
        console.log('[displayFlashcard] StudyConfig is already an object:', normalizedCard.StudyConfig);
        studyConfig = { ...studyConfig, ...normalizedCard.StudyConfig };
      } else if (typeof normalizedCard.StudyConfig === 'string') {
        try {
          // Handle potential non-JSON strings that might be "true" or "false"
          if (normalizedCard.StudyConfig.trim().toLowerCase() === 'true') {
            studyConfig = { showSideB: true, showSideC: true, autoplayAudio: false };
          } else if (normalizedCard.StudyConfig.trim().toLowerCase() === 'false') {
            studyConfig = { showSideB: false, showSideC: false, autoplayAudio: false };
          } else {
            // Normal JSON parsing
            const parsedConfig = JSON.parse(normalizedCard.StudyConfig);
            studyConfig = { ...studyConfig, ...parsedConfig };
          }
        } catch (e) {
          console.error('[displayFlashcard] Failed to parse study configuration:', e, "Raw config:", normalizedCard.StudyConfig);
        }
      }
    }

    console.log('[displayFlashcard] Processing StudyConfig for card:', normalizedCard.id || 'unknown');
    console.log('[displayFlashcard] Raw StudyConfig:', normalizedCard.StudyConfig);

    // Ensure boolean values
    studyConfig.showSideB = Boolean(studyConfig.showSideB);
    studyConfig.showSideC = Boolean(studyConfig.showSideC);
    studyConfig.autoplayAudio = Boolean(studyConfig.autoplayAudio);

    console.log('[displayFlashcard] Final StudyConfig:', JSON.stringify(studyConfig));

    // Better content detection logic
    // Your existing content detection logic
    let sideBneedsProcessing = studyConfig.showSideB && 
                            normalizedCard.sideB && 
                            typeof normalizedCard.sideB === 'string' &&
                            (normalizedCard.sideB.includes('[AUDIO:') || normalizedCard.sideB.includes('[IMAGE:'));

    let sideCneedsProcessing = studyConfig.showSideC && 
                            normalizedCard.sideC && 
                            typeof normalizedCard.sideC === 'string' &&
                            (normalizedCard.sideC.includes('[AUDIO:') || normalizedCard.sideC.includes('[IMAGE:'));

    console.log('[displayFlashcard] Content processing needed - SideB:', sideBneedsProcessing, 'SideC:', sideCneedsProcessing);
    
    contentArea.innerHTML = `
      <div class="flashcard-container">
        <div class="deck-info">
          <h2>${escapeHtml(window.app.currentDeck)}</h2>
          <div class="progress">Card ${index + 1} of ${cards.length}</div>
        </div>
        
        <div class="flashcard" id="currentCard">
          <div class="flashcard-front">
            <div class="flashcard-content">${escapeHtml(normalizedCard.sideA || '')}</div>
            <div class="flashcard-helper">Click to flip</div>
          </div>
          <div class="flashcard-back">
            <div class="flashcard-content" id="flashcardSideBContent"></div>
            <div class="flashcard-secondary" id="flashcardSideCContent"></div>
          </div>
        </div>
        
        <div class="rating-buttons" style="display: none;" id="ratingButtons">
          <button class="rating-btn rating-btn-again" data-rating="0">
            <span class="material-icons">sentiment_very_dissatisfied</span>
            <span>Again</span>
          </button>
          <button class="rating-btn rating-btn-hard" data-rating="1">
            <span class="material-icons">sentiment_dissatisfied</span>
            <span>Hard</span>
          </button>
          <button class="rating-btn rating-btn-good" data-rating="2">
            <span class="material-icons">sentiment_satisfied</span>
            <span>Good</span>
          </button>
          <button class="rating-btn rating-btn-easy" data-rating="3">
            <span class="material-icons">sentiment_very_satisfied</span>
            <span>Easy</span>
          </button>
        </div>
        
        <div class="flashcard-controls">
          <button id="backToDeckList" class="btn btn-outline">Back to Decks</button>
        </div>
      </div>
    `;
    
    let sideBneedsProcessing = studyConfig.showSideB && normalizedCard.sideB && (normalizedCard.sideB.includes('[AUDIO:') || normalizedCard.sideB.includes('[IMAGE:'));
    let sideCneedsProcessing = studyConfig.showSideC && normalizedCard.sideC && (normalizedCard.sideC.includes('[AUDIO:') || normalizedCard.sideC.includes('[IMAGE:'));
    
    let sideBprocessed = !sideBneedsProcessing;
    let sideCprocessed = !sideCneedsProcessing;

    function checkAndSetupAllAudio() {
      if (sideBprocessed && sideCprocessed) {
        const flashcardBackElement = document.querySelector('#currentCard .flashcard-back');
        if (flashcardBackElement) {
          console.log('[displayFlashcard] Both sides processed. Setting up audio buttons.');
          setupAudioButtons(flashcardBackElement);
          if (studyConfig.autoplayAudio && flashcardBackElement.classList.contains('flipped')) {
             // Autoplay logic if needed here, or handled by flip event
          }
        }
      }
    }
    
    if (sideBneedsProcessing) {
      console.log('[displayFlashcard] Processing Side B for dictionary content.');
      google.script.run
        .withSuccessHandler(function(processedContent) {
          console.log('[displayFlashcard] renderDictionaryContent success for Side B:', processedContent.substring(0,100) + "...");
          const mainContentElement = document.getElementById('flashcardSideBContent');
          if (mainContentElement) {
            mainContentElement.innerHTML = processedContent;
          }
          sideBprocessed = true;
          checkAndSetupAllAudio();
        })
        .withFailureHandler(function(err){
          console.error("[displayFlashcard] Failed to render Side B dictionary content:", err);
          const mainContentElement = document.getElementById('flashcardSideBContent');
          if (mainContentElement) mainContentElement.innerHTML = '<p style="color:red">Error loading Side B content.</p>';
          sideBprocessed = true; 
          checkAndSetupAllAudio();
        })
        .renderDictionaryContent(normalizedCard.sideB);
    } else {
        // If not processing, ensure content is still there if it's plain text
        const mainContentElement = document.getElementById('flashcardSideBContent');
        if (mainContentElement && studyConfig.showSideB && hasValidContent(normalizedCard.sideB)) {
             mainContentElement.innerHTML = escapeHtml(normalizedCard.sideB || '').replace(/\r\n|\r|\n/g, '<br>');
        } else if (mainContentElement) {
             mainContentElement.innerHTML = ''; // Clear if not shown or no content
        }
    }
    
    if (sideCneedsProcessing) {
      console.log('[displayFlashcard] Processing Side C for dictionary content.');
      google.script.run
        .withSuccessHandler(function(processedContent) {
          console.log('[displayFlashcard] renderDictionaryContent success for Side C:', processedContent.substring(0,100) + "...");
          const secondaryContentElement = document.getElementById('flashcardSideCContent');
          if (secondaryContentElement) {
            secondaryContentElement.innerHTML = processedContent;
          }
          sideCprocessed = true;
          checkAndSetupAllAudio();
        })
        .withFailureHandler(function(err){
          console.error("[displayFlashcard] Failed to render Side C dictionary content:", err);
          const secondaryContentElement = document.getElementById('flashcardSideCContent');
          if (secondaryContentElement) secondaryContentElement.innerHTML = '<p style="color:red">Error loading Side C content.</p>';
          sideCprocessed = true;
          checkAndSetupAllAudio();
        })
        .renderDictionaryContent(normalizedCard.sideC);
    } else {
        // If not processing, ensure content is still there if it's plain text
        const secondaryContentElement = document.getElementById('flashcardSideCContent');
        if (secondaryContentElement && studyConfig.showSideC && hasValidContent(normalizedCard.sideC)) {
             secondaryContentElement.innerHTML = escapeHtml(normalizedCard.sideC || '').replace(/\r\n|\r|\n/g, '<br>');
        } else if (secondaryContentElement) {
             secondaryContentElement.innerHTML = ''; // Clear if not shown or no content
        }
    }

    if (!sideBneedsProcessing && !sideCneedsProcessing) {
      // If no async processing, call setup immediately
      checkAndSetupAllAudio();
    }
    
    const flashcardElement = document.getElementById('currentCard');
    if (flashcardElement) {
      flashcardElement.addEventListener('click', function() {
        this.classList.toggle('flipped');
        const ratingButtons = document.getElementById('ratingButtons');
        if (ratingButtons) {
            if (this.classList.contains('flipped')) {
                ratingButtons.style.display = 'flex';
                // Autoplay audio if configured and card is flipped to back
                if (studyConfig.autoplayAudio) {
                    const firstAudioButton = this.querySelector('.flashcard-back .audio-play-btn');
                    if (firstAudioButton && !firstAudioButton.classList.contains('playing')) {
                        console.log('[displayFlashcard] Autoplaying audio on flip.');
                        firstAudioButton.click(); // Simulate click to play and update icon
                    }
                }
            } else {
                ratingButtons.style.display = 'none';
                // Stop all audio when flipping back to front
                document.querySelectorAll('#currentCard .flashcard-back audio').forEach(audioEl => {
                    if (!audioEl.paused) {
                        audioEl.pause();
                        audioEl.currentTime = 0;
                        const button = audioEl.closest('.audio-play-btn');
                        if (button) {
                           button.classList.remove('playing');
                           const iconEl = button.querySelector('.material-icons');
                           if (iconEl) iconEl.textContent = 'play_arrow';
                        }
                    }
                });
            }
        }
      });
    }
    
    document.querySelectorAll('.rating-btn').forEach(btn => {
      btn.addEventListener('click', function(e) {
        e.stopPropagation(); 
        const rating = parseInt(this.getAttribute('data-rating'));
        rateCard(normalizedCard.id, rating, cards, index);
      });
    });
    
    const backToDeckListButton = document.getElementById('backToDeckList');
    if (backToDeckListButton) {
        backToDeckListButton.addEventListener('click', loadDeckList);
    }
  }
  
  /**
   * Rate a flashcard and move to the next one
   * 
   * @param {string} cardId - ID of the card
   * @param {number} rating - Rating value (0-3)
   * @param {Array} cards - Array of cards
   * @param {number} index - Current card index
   */
  function rateCard(cardId, rating, cards, index) {
    showLoadingIndicator();
    console.log('[rateCard] Rating cardId:', cardId, 'with rating:', rating);
    
    google.script.run
      .withSuccessHandler(function(result) {
        hideLoadingIndicator();
        if (result && result.success) {
          console.log('[rateCard] Successfully rated card. Server response:', result);
          displayFlashcard(cards, index + 1);
        } else {
          console.error('[rateCard] Failed to record card rating. Server response:', result);
          handleError(result ? result.message : 'Failed to record card rating.');
        }
      })
      .withFailureHandler(function(err){
        console.error('[rateCard] Error occurred while rating card:', err);
        handleError(err.message || 'An error occurred while rating the card.');
      })
      .recordCardRating(window.app.currentDeck, cardId, rating);
  }
  
  /**
   * Show deck completion screen
   */
  function showDeckComplete() {
    const contentArea = document.getElementById('appContent');
    console.log('[showDeckComplete] Displaying deck completion screen.');
    
    contentArea.innerHTML = `
      <div class="card">
        <div class="card-title">Well done!</div>
        <p>You have completed studying this deck.</p>
        <div class="form-actions" style="margin-top: 20px;">
          <button id="backToDeckList" class="btn">Back to Decks</button>
          <button id="restartDeck" class="btn btn-outline">Study Again</button>
        </div>
      </div>
    `;
    
    const backButton = document.getElementById('backToDeckList');
    if (backButton) backButton.addEventListener('click', loadDeckList);
    
    const restartButton = document.getElementById('restartDeck');
    if (restartButton) restartButton.addEventListener('click', function() {
      if (window.app.currentDeck) {
        console.log('[showDeckComplete] Restarting deck:', window.app.currentDeck);
        loadDeck(window.app.currentDeck);
      } else {
        console.warn('[showDeckComplete] currentDeck not set, loading deck list as fallback.');
        loadDeckList();
      }
    });
  }
</script>